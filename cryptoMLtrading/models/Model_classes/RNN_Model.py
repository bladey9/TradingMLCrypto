# -*- coding: utf-8 -*-
"""RNN_Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dbIJHXYd63_8HTTgmc7sWW9TMxGHnQtt
"""

import pandas as pd
import numpy as np
#pd.options.display.max_rows = None
pd.options.display.max_columns = None
import requests
np.set_printoptions(suppress=True)
from numpy import loadtxt
import tensorflow as tf
from tensorflow import keras
from tensorflow.python.keras.layers import Input, Dense,BatchNormalization, Dropout,LSTM, CuDNNLSTM
from tensorflow.python.keras.models import Sequential 
from tensorflow.python.keras.wrappers.scikit_learn import KerasClassifier
from tensorflow.python.keras.utils import np_utils
from tensorflow.keras.callbacks import TensorBoard, ModelCheckpoint
from tensorflow.keras.callbacks import TensorBoard
from tensorflow.keras.callbacks import ModelCheckpoint, ModelCheckpoint
from sklearn.preprocessing import LabelEncoder
import random
from collections import deque
import matplotlib.pyplot as plt

#%tensorflow_version 1.x

class RNN():

    def __init__(self, train_df, valid_df, test_df):
      self.train_data = train_df
      self.valid_data = valid_df
      self.test_data = test_df
      self.run()

    def run(self):
      self.X_train, self.y_train = self.preprocess(self.train_data)
      self.X_valid, self.y_valid = self.preprocess(self.valid_data)
      self.X_test, self.y_test = self.preprocess(self.test_data)

    def preprocess(self,dataframe):
      sequential_data = []
      prev_days = deque(maxlen=5)
      for i in dataframe.values:
          prev_days.append([n for n in i[:-1]])
          if len(prev_days) == 5:
              sequential_data.append([np.array(prev_days),i[-1]])
      
      random.shuffle(sequential_data)
      X = []
      y = []
      for seq, target in sequential_data:
          X.append(seq)
          y.append(target)

      y = self.encode(y)

      return np.array(X), y

  
    def encode(self,y):
      #Method that converts integers to dummy variables (i.e. one hot encoded)
      encoder = LabelEncoder()
      encoder.fit(y)
      encoded_Y = encoder.transform(y)
      y = np_utils.to_categorical(encoded_Y)
      return y

    def run_model(self):

      model = Sequential()
      model.add(CuDNNLSTM(128, input_shape=(self.X_train.shape[1:]), return_sequences=True))
      model.add(Dropout(0.2))
      model.add(BatchNormalization())  #normalizes activation outputs, same reason you want to normalize your input data.

      model.add(CuDNNLSTM(64, return_sequences=True))
      model.add(Dropout(0.2))
      model.add(BatchNormalization())  #normalizes activation outputs, same reason you want to normalize your input data.

      model.add(CuDNNLSTM(64, return_sequences=True))
      model.add(Dropout(0.2))
      model.add(BatchNormalization())

      model.add(CuDNNLSTM(32,))
      model.add(Dropout(0.1))
      model.add(BatchNormalization())

      model.add(Dense(32, activation='relu'))
      model.add(Dropout(0.2))

      model.add(Dense(4,activation='softmax'))


      opt = tf.keras.optimizers.Adam(lr = 0.001, decay = 1e-5)

      model.compile(loss = "categorical_crossentropy",
                  optimizer = 'Adam',
                  metrics = ["accuracy"])


      #tensorboard = TensorBoard(log_dir = )

      model.fit(self.X_train, self.y_train, batch_size = 128, epochs = 5, validation_data = (self.X_valid, self.y_valid), validation_split =0.2)

      preds = model.predict(self.X_test)
      self.get_accuracy(preds)
      return main_model

    def get_accuracy(self, predictions):
        
      predictions_full = []
      for each in predictions:
          ind = np.argmax(each)
          predictions_full.append(ind)
      real_values = []
      for each in self.y_test:
          ind = np.argmax(each)
          real_values.append(ind)

      print("Length match up test:", len(predictions)==len(self.y_test), len(predictions_full)== len(real_values))
      accuracy = 0
      for i in range(len(predictions_full)):
          if predictions_full[i] == real_values[i]:
              accuracy += 1

      print("Test Accuracy: ",accuracy/len(predictions_full))

