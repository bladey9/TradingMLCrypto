# -*- coding: utf-8 -*-
"""Ensemble_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vsmsawrW5LZQCv0f7uyf3txwSLfcJyjG
"""

import pandas as pd
from sklearn.metrics import confusion_matrix
from sklearn import metrics
from sklearn.model_selection import train_test_split
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import pickle
import tensorflow as tf
from tensorflow import keras
from collections import deque

from tensorflow.python.keras.wrappers.scikit_learn import KerasClassifier
from tensorflow.python.keras.utils import np_utils
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.preprocessing import LabelEncoder
from sklearn.pipeline import Pipeline
from tensorflow.python.keras.models import load_model

from keras.models import Sequential
from keras.layers import Dense, Dropout, LSTM, BatchNormalization
from keras.callbacks import TensorBoard
from keras.callbacks import ModelCheckpoint
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder


from tensorflow.keras.optimizers import Adam, Nadam, RMSprop
from keras.losses import CategoricalCrossentropy

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 1.x

class Ensemble:
    
    def __init__(self, train_concat, valid_concat, test_concat, train_sequenced, valid_sequenced, test_sequenced,
                RF, LR, NN, NN2, RNN):
        self.train_concat = train_concat
        self.valid_concat = valid_concat
        self.test_concat = test_concat
        self.train_sequenced = train_sequenced
        self.valid_sequenced = valid_sequenced
        self.test_sequenced = test_sequenced
        
        self.RF = RF
        self.LR = LR
        self.NN1 = NN
        self.NN2 = NN2
        self.RNN = RNN
        
        self.run()
    
    def run(self):
        self.X_train_concat, self.y_train_concat = self.split(self.train_concat[4:])
        self.X_valid_concat, self.y_valid_concat = self.split(self.valid_concat[4:])
        self.X_test_concat, self.y_test_concat = self.split(self.test_concat[4:])
        
        self.X_train_RNN, self.y_train_RNN = self.preprocess(self.train_sequenced)
        self.X_valid_RNN, self.y_valid_RNN = self.preprocess(self.valid_sequenced)
        self.X_test_RNN, self.y_test_RNN = self.preprocess(self.test_sequenced)
    
        self.get_model_predictions()
        
    def split(self,dataframe):
        # Split X and y data into 2 dataframes
        X_train = dataframe.loc[:, dataframe.columns != 'label']
        #X.head()
        y_train = dataframe.loc[:, dataframe.columns == 'label']
        #y.head()
        y_train = self.encode(y_train)
        return X_train, y_train
    
    
    def encode(self,y):
        #Method that converts integers to dummy variables (i.e. one hot encoded)
        encoder = LabelEncoder()
        encoder.fit(y)
        encoded_Y = encoder.transform(y)
        y = np_utils.to_categorical(encoded_Y)
        return y

    def preprocess(self,test_df):
        '''
        Generate sequenced dataframe from sequential dataframe.
        '''
        sequential_data = []
        prev_days = deque(maxlen=5)
        for i in test_df.values:
            prev_days.append([n for n in i[:-1]])
            if len(prev_days) == 5:
                sequential_data.append([np.array(prev_days),i[-1]])
        X = []
        y = []
        for seq, target in sequential_data:
            X.append(seq)
            y.append(target)
        
        y = self.encode(y)

        return np.array(X), y

    def get_model_predictions(self):
        
        RF_preds_for_ensemble = self.RF.predict_proba(self.X_train_concat.values)
        LR_preds_for_ensemble = self.LR.predict_proba(self.X_train_concat.values)
        NN1_preds_for_ensemble = self.NN1.predict(self.X_train_concat.values)
        NN2_preds_for_ensemble = self.NN2.predict(self.X_train_concat.values)
        RNN_preds_for_ensemble = self.RNN.predict(self.X_train_RNN)
        
        print("Predicting training values completed 1/3")
        
        RF_preds_for_ensemble_valid = self.RF.predict_proba(self.X_valid_concat.values)
        LR_preds_for_ensemble_valid  = self.LR.predict_proba(self.X_valid_concat.values)
        NN1_preds_for_ensemble_valid  = self.NN1.predict(self.X_valid_concat.values)
        NN2_preds_for_ensemble_valid  = self.NN2.predict(self.X_valid_concat.values)
        RNN_preds_for_ensemble_valid  = self.RNN.predict(self.X_valid_RNN)
        
        print("Predicting validation values completed 2/3")
        
        RF_preds_for_ensemble_test = self.RF.predict_proba(self.X_test_concat.values)
        LR_preds_for_ensemble_test = self.LR.predict_proba(self.X_test_concat.values)
        NN1_preds_for_ensemble_test = self.NN1.predict(self.X_test_concat.values)
        NN2_preds_for_ensemble_test = self.NN2.predict(self.X_test_concat.values)
        RNN_preds_for_ensemble_test = self.RNN.predict(self.X_test_RNN)
        
        print("Predicting testing values completed 3/3")
        
        self.concat_preds_EE_train = np.concatenate((RF_preds_for_ensemble,LR_preds_for_ensemble,NN1_preds_for_ensemble,NN2_preds_for_ensemble,RNN_preds_for_ensemble), axis=1)
        self.concat_preds_EE_valid = np.concatenate((RF_preds_for_ensemble_valid,LR_preds_for_ensemble_valid,NN1_preds_for_ensemble_valid,NN2_preds_for_ensemble_valid,RNN_preds_for_ensemble_valid), axis=1)
        self.concat_preds_EE_test = np.concatenate((RF_preds_for_ensemble_test,LR_preds_for_ensemble_test,NN1_preds_for_ensemble_test,NN2_preds_for_ensemble_test,RNN_preds_for_ensemble_test), axis=1)

        print("concatenation of individual models' predictions completed 4/4")
        
    
    def run_model(self):
    
        main_model = Sequential()
        main_model.add(Dense(64, input_dim=self.concat_preds_EE_train.shape[1], activation='relu'))
        main_model.add(Dropout(0.2))

        main_model.add(Dense(32, input_dim=64, activation='relu'))
        main_model.add(Dropout(0.2))

        main_model.add(Dense(16, input_dim=16, activation='relu'))
        main_model.add(Dropout(0.2))

        main_model.add(Dense(4, activation='softmax'))

        optimizer = keras.optimizers.Adam(learning_rate=0.001)

        main_model.compile(optimizer= optimizer, loss='categorical_crossentropy', metrics=['accuracy',"MSE"])
        main_model.fit(self.concat_preds_EE_train, self.y_train_concat, epochs=5, validation_data =(self.concat_preds_EE_valid,self.y_valid_concat), validation_split =0.1)

        predictions = main_model.predict(self.concat_preds_EE_test)
        self.get_accuracy(predictions)
        return main_model 
    
    def get_accuracy(self,predictions): 

        print(len(predictions) == len(self.y_test_concat))
        predictions_full = []
        for each in predictions:
            ind = np.argmax(each)
            predictions_full.append(ind)

        real_values = []
        for each in self.y_test_concat:
            ind = np.argmax(each)
            real_values.append(ind)

        print("Length match up test:", len(predictions)==len(self.y_test_concat), len(predictions_full)== len(real_values))
        accuracy = 0
        for i in range(len(predictions_full)):
            if predictions_full[i] == real_values[i]:
                accuracy += 1


        print("Test Accuracy: ",accuracy/len(predictions_full))

